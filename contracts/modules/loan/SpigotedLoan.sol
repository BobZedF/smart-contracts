
pragma solidity ^0.8.9;

import { BaseLoan } from "./BaseLoan.sol";
import { ISpigotedLoan } from "../../interfaces/ISpigotedLoan.sol";
import { LoanLib } from "../../utils/LoanLib.sol";
import { SpigotConsumer } from "../spigot/SpigotConsumer.sol";

abstract contract SpigotedLoan is BaseLoan, SpigotConsumer, ISpigotedLoan {

    /**
   * @dev - BaseLoan contract with additional functionality for integrating with Spigot and borrower revenue streams to repay loans
   * @param maxDebtValue_ - total debt accross all lenders that borrower is allowed to create
   * @param oracle_ - price oracle to use for getting all token values
   * @param spigot_ - contract securing/repaying loan from borrower revenue streams
   * @param arbiter_ - neutral party with some special priviliges on behalf of borrower and lender
   * @param borrower_ - the debitor for all debt positions in this contract
   * @param interestRateModel_ - contract calculating lender interest from debt position values
  */
  constructor(
    uint256 maxDebtValue_,
    address oracle_,
    address arbiter_,
    address borrower_,
    address interestRateModel_,
    address swapTarget_,
    uint8 defaultRevenueSplit_
  )
    BaseLoan(maxDebtValue_, oracle_, arbiter_, borrower_, interestRateModel_)
    SpigotConsumer(borrower_, swapTarget_, defaultRevenueSplit_)
  {

    loanStatus = LoanLib.STATUS.INITIALIZED;
  }

  function updateOwnerSplit(address revenueContract) external {
    uint256 length = revenueContracts.length;
    ( , uint8 split, , bytes4 transferFunc) = spigot.getSetting(revenueContract);
    
    if(transferFunc == bytes4(0)) continue; // no spigot set for contract address

    if(loanStatus == LoanLib.STATUS.ACTIVE && split != defaultRevenueSplit) {
      // if loan is healthy set split to default take rate
      spigot.updateOwnerSplit(revenueContract, defaultRevenueSplit);
    } else if (
      split != MAX_SPLIT && 
      (loanStatus == LoanLib.STATUS.DELINQUENT || loanStatus == LoanLib.STATUS.LIQUIDATABLE)
    ) {
      // if loan is in distress take all revenue to repay loan
      spigot.updateOwnerSplit(revenueContract, MAX_SPLIT);
    }
  }

 /**
   * @dev - Claims revenue tokens from Spigot attached to borrowers revenue generating tokens
            and sells them via 0x protocol to repay debts
            Only callable by borrower for security pasing arbitrary data in contract call
            and they are most incentivized to get best price on assets being sold.
   * @notice see _repay() for more details
   * @param positionId -the debt position to pay down debt on
   * @param claimToken - The revenue token escrowed by Spigot to claim and use to repay debt
   * @param zeroExTradeData - data generated by 0x API to trade `claimToken` against their exchange contract
  */
  function claimSpigotAndRepay(
    bytes32 positionId,
    address claimToken,
    bytes calldata zeroExTradeData
  )
    validPositionId(positionId)
    external
    returns(bool)
  {
    require(msg.sender == borrower || msg.sender == arbieter);
    _accrueInterest(positionId);
    
    DebtPosition memory debt = debts[positionId];

    // need to check with 0x api on where bought tokens go to by default
    // see if we can change that to Loan instead of SpigotConsumer
    uint256 tokensBought = _claimAndTrade(
      claimToken,
      debt.token,
      zeroExTradeData
    );

    // TODO check if early repayment is allowed on loan
    // then update logic here. Probs need an internal func
    uint256 amountToRepay = _getMaxRepayableAmount(positionId, tokensBought);

    _repay(positionId, amountToRepay);

    emit RevenuePayment(
      claimToken,
      _getTokenPrice(debt.token) * amountToRepay
    );

    return true;
  }
}
