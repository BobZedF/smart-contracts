{
  "address": "0x1B7693e8E99e03CF3BC18a7B8982e184Bbd8021F",
  "abi": [],
  "transactionHash": "0x58d924f876f93573f5a53a7f15c5bd0212a734b4d016c675feef2498ccbec84a",
  "receipt": {
    "to": null,
    "from": "0x41d28426925E8201b2A163C4bC1A45D9EAFb32f4",
    "contractAddress": "0x1B7693e8E99e03CF3BC18a7B8982e184Bbd8021F",
    "transactionIndex": 11,
    "gasUsed": "316444",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x4959773cca9a193b43802416fd862aff5ce566a4178347efa5c836a6b3d48ac1",
    "transactionHash": "0x58d924f876f93573f5a53a7f15c5bd0212a734b4d016c675feef2498ccbec84a",
    "logs": [],
    "blockNumber": 7381231,
    "cumulativeGasUsed": "1988463",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "2a60ac237244dc390ce3bdbc44555d3c",
  "metadata": "{\"compiler\":{\"version\":\"0.8.9+commit.e5eed63a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"author\":\"Kiba Gateaux\",\"kind\":\"dev\",\"methods\":{\"removePosition(bytes32[] storage,bytes32)\":{\"details\":\"assumes that `id` is stored only once in `positions` array bc no reason for Loans to store multiple times. This means cleanup on _close() and checks on addDebtPosition are CRITICAL. If `id` is duplicated then the position can't be closed\",\"params\":{\"id\":\"- hash id that must be removed from active positions\",\"ids\":\"- all current active positions on the loan\"},\"returns\":{\"_0\":\"newPositions - all active positions on loan after `id` is removed\"}},\"stepQ(bytes32[] storage)\":{\"params\":{\"ids\":\"- all current active positions on the loan\"},\"returns\":{\"_0\":\"newPositions - positions after moving first to last in array\"}}},\"title\":\"Debt DAO P2P Loan Library\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"stepQ(bytes32[] storage)\":{\"notice\":\"- removes debt position from head of repayement queue and puts it at end of line         - moves 2nd in line to first\"}},\"notice\":\"Core logic and variables to be reused across all Debt DAO Marketplace loans\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/utils/CreditListLib.sol\":\"CreditListLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/interfaces/IInterestRateCredit.sol\":{\"content\":\"pragma solidity ^0.8.9;\\n\\ninterface IInterestRateCredit {\\n  struct Rate {\\n    // interest rate on amount currently being borrower\\n    // in bps, 4 decimals\\n    uint128 drawnRate;\\n    // interest rate on amount deposited by lender but not currently being borrowed\\n    // in bps, 4 decimals\\n    uint128 facilityRate;\\n    // timestamp that interest was last accrued on this position\\n    uint256 lastAccrued;\\n  }\\n\\n  function accrueInterest(\\n    bytes32 positionId,\\n    uint256 drawnAmount,\\n    uint256 facilityAmount\\n  ) external returns(uint256);\\n\\n  function setRate(\\n    bytes32 positionId,\\n    uint128 drawnRate,\\n    uint128 facilityRate\\n  ) external returns(bool);\\n}\\n\",\"keccak256\":\"0x327d41c69ed0b4fe4ff4e74801df7ee1d90ff90cc0b52b737fccd699f6e3fea8\"},\"contracts/interfaces/ILineOfCredit.sol\":{\"content\":\"pragma solidity 0.8.9;\\n\\nimport { LoanLib } from \\\"../utils/LoanLib.sol\\\";\\nimport { ILoan } from \\\"./ILoan.sol\\\";\\nimport { IOracle } from \\\"../interfaces/IOracle.sol\\\";\\n\\ninterface ILineOfCredit is ILoan {\\n  // Lender data\\n  struct Credit {\\n    //  all denominated in token, not USD\\n    uint256 deposit;          // total liquidity provided by lender for token\\n    uint256 principal;        // amount actively lent out\\n    uint256 interestAccrued;  // interest accrued but not repaid\\n    uint256 interestRepaid;   // interest repaid by borrower but not withdrawn by lender\\n    uint8 decimals;           // decimals of credit token for calcs\\n    address token;            // token being lent out\\n    address lender;           // person to repay\\n  }\\n\\n  event SetRates(bytes32 indexed id, uint128 indexed drawnRate, uint128 indexed facilityRate);\\n\\n\\n  // Access Errors\\n  error NotActive();\\n  error NotBorrowing();\\n  error CallerAccessDenied();\\n  \\n  // Tokens\\n  error TokenTransferFailed();\\n  error NoTokenPrice();\\n\\n  // Loan\\n  error BadModule(address module);\\n  error NoLiquidity(bytes32 position);\\n  error PositionExists();\\n  error CloseFailedWithPrincipal();\\n\\n  function init() external returns(LoanLib.STATUS);\\n\\n  function addCredit(\\n    uint128 drate,\\n    uint128 frate,\\n    uint256 amount,\\n    address token,\\n    address lender\\n  ) external returns(bytes32);\\n\\n  function setRates(\\n    bytes32 id,\\n    uint128 drate,\\n    uint128 frate\\n  ) external returns(bool);\\n\\n  function increaseCredit(bytes32 id, uint256 amount) external returns(bool);\\n\\n  function borrow(bytes32 id, uint256 amount) external returns(bool);\\n  function depositAndRepay(uint256 amount) external returns(bool);\\n  function depositAndClose() external returns(bool);\\n  function close(bytes32 id) external returns(bool);\\n\\n  function withdraw(bytes32 id, uint256 amount) external returns(bool);\\n\\n  function accrueInterest() external returns(bool);\\n  function updateOutstandingDebt() external returns(uint256, uint256);\\n  function healthcheck() external returns(LoanLib.STATUS);\\n\\n  function borrower() external returns(address);\\n  function arbiter() external returns(address);\\n  function oracle() external returns(IOracle);\\n}\\n\",\"keccak256\":\"0xf69a055a8cfaccd9b612207a0a49e0fdfedf3776e3a6e5a7edf0fb5c6d6cbe60\"},\"contracts/interfaces/ILoan.sol\":{\"content\":\"pragma solidity 0.8.9;\\n\\nimport { LoanLib } from \\\"../utils/LoanLib.sol\\\";\\n\\ninterface ILoan {\\n\\n  // General Events\\n  event UpdateLoanStatus(uint256 indexed status); // store as normal uint so it can be indexed in subgraph\\n\\n  event DeployLoan(\\n    address indexed oracle,\\n    address indexed arbiter,\\n    address indexed borrower\\n  );\\n\\n  // Lender Events\\n\\n  event AddCredit(\\n    address indexed lender,\\n    address indexed token,\\n    uint256 indexed deposit,\\n    bytes32 positionId\\n  );\\n\\n\\n   event IncreaseCredit (bytes32 indexed id, uint256 indexed deposit);\\n\\n  // can reference only id once AddCredit is emitted because it will be stored in subgraph\\n  // initialPrinicipal tells us if its a Revolver or Term\\n\\n  event WithdrawDeposit(bytes32 indexed id, uint256 indexed amount);\\n  // lender removing funds from Loan  principal\\n  event WithdrawProfit(bytes32 indexed id, uint256 indexed amount);\\n  // lender taking interest earned out of contract\\n\\n  event CloseCreditPosition(bytes32 indexed id);\\n  // lender officially repaid in full. if Credit then facility has also been closed.\\n\\n  event InterestAccrued(bytes32 indexed id, uint256 indexed amount);\\n  // interest added to borrowers outstanding balance\\n\\n\\n  // Borrower Events\\n\\n  event Borrow(bytes32 indexed id, uint256 indexed amount);\\n  // receive full loan or drawdown on credit\\n\\n  event RepayInterest(bytes32 indexed id, uint256 indexed amount);\\n\\n  event RepayPrincipal(bytes32 indexed id, uint256 indexed amount);\\n\\n  event Default(bytes32 indexed id);\\n}\\n\",\"keccak256\":\"0x63d7f761402d6d221e38e1d8fe3302e1a1f153ea7835f6ac96966f43fa6ee7be\"},\"contracts/interfaces/IOracle.sol\":{\"content\":\"pragma solidity 0.8.9;\\n\\ninterface IOracle {\\n    /** current price for token asset. denominated in USD */\\n    function getLatestAnswer(address token) external returns(int);\\n}\\n\",\"keccak256\":\"0xdefae1f6dd298ddfba2a88c77096e77e59ac0a567bc3c8e76ef5a3424e4b832f\"},\"contracts/utils/CreditLib.sol\":{\"content\":\"pragma solidity 0.8.9;\\nimport { ILineOfCredit } from \\\"../interfaces/ILineOfCredit.sol\\\";\\nimport { IOracle } from \\\"../interfaces/IOracle.sol\\\";\\nimport { IInterestRateCredit } from \\\"../interfaces/IInterestRateCredit.sol\\\";\\nimport { ILoan } from \\\"../interfaces/ILoan.sol\\\";\\nimport { LoanLib } from \\\"./LoanLib.sol\\\";\\n\\n/**\\n  * @title Debt DAO P2P Loan Library\\n  * @author Kiba Gateaux\\n  * @notice Core logic and variables to be reused across all Debt DAO Marketplace loans\\n */\\nlibrary CreditLib {\\n\\n    event AddCredit(\\n        address indexed lender,\\n        address indexed token,\\n        uint256 indexed deposit,\\n        bytes32 positionId\\n    );\\n\\n  event WithdrawDeposit(bytes32 indexed id, uint256 indexed amount);\\n  // lender removing funds from Loan  principal\\n  event WithdrawProfit(bytes32 indexed id, uint256 indexed amount);\\n  // lender taking interest earned out of contract\\n\\n  event InterestAccrued(bytes32 indexed id, uint256 indexed amount);\\n  // interest added to borrowers outstanding balance\\n\\n\\n  // Borrower Events\\n\\n  event Borrow(bytes32 indexed id, uint256 indexed amount);\\n  // receive full loan or drawdown on credit\\n\\n  event RepayInterest(bytes32 indexed id, uint256 indexed amount);\\n\\n  event RepayPrincipal(bytes32 indexed id, uint256 indexed amount);\\n\\n\\n  error NoTokenPrice();\\n\\n  error PositionExists();\\n\\n\\n  /**\\n   * @dev          - Create deterministic hash id for a debt position on `loan` given position details\\n   * @param loan   - loan that debt position exists on\\n   * @param lender - address managing debt position\\n   * @param token  - token that is being lent out in debt position\\n   * @return positionId\\n   */\\n  function computePositionId(\\n    address loan,\\n    address lender,\\n    address token\\n  )\\n    external pure\\n    returns(bytes32)\\n  {\\n    return _computePositionId(loan, lender, token);\\n  }\\n\\n  function _computePositionId(\\n    address loan,\\n    address lender,\\n    address token\\n  )\\n    internal pure\\n    returns(bytes32)\\n  {\\n    return keccak256(abi.encode(loan, lender, token));\\n  }\\n\\n\\n    function getOutstandingDebt(\\n      ILineOfCredit.Credit memory credit,\\n      bytes32 id,\\n      address oracle,\\n      address interestRate\\n    )\\n      external\\n      returns (ILineOfCredit.Credit memory c, uint256 principal, uint256 interest)\\n    {\\n        c = _accrue(credit, id, IInterestRateCredit(interestRate)); // Issue is accruing interest from here\\n\\n        int256 price = IOracle(oracle).getLatestAnswer(c.token);\\n\\n        principal += _calculateValue(\\n            price,\\n            c.principal,\\n            c.decimals\\n        );\\n        interest += _calculateValue(\\n            price,\\n            c.interestAccrued,\\n            c.decimals\\n        );\\n\\n        return (c, principal, interest);\\n  }\\n\\n   /**\\n     * @notice         - Gets total valuation for amount of tokens using given oracle. \\n     * @dev            - Assumes oracles all return answers in USD with 1e8 decimals\\n                       - Does not check if price < 0. HAndled in Oracle or Loan\\n     * @param oracle   - oracle contract specified by loan getting valuation\\n     * @param token    - token to value on oracle\\n     * @param amount   - token amount\\n     * @param decimals - token decimals\\n     * @return         - total value in usd of all tokens \\n     */\\n    function getValuation(\\n      IOracle oracle,\\n      address token,\\n      uint256 amount,\\n      uint8 decimals\\n    )\\n      external\\n      returns(uint256)\\n    {\\n      return _calculateValue(oracle.getLatestAnswer(token), amount, decimals);\\n    }\\n\\n    /**\\n     * @notice\\n     * @dev            - Assumes oracles all return answers in USD with 1e8 decimals\\n                       - Does not check if price < 0. HAndled in Oracle or Loan\\n     * @param price    - oracle price of asset. 8 decimals\\n     * @param amount   - amount of tokens vbeing valued.\\n     * @param decimals - token decimals to remove for usd price\\n     * @return         - total USD value of amount in 8 decimals \\n     */\\n    function calculateValue(\\n      int price,\\n      uint256 amount,\\n      uint8 decimals\\n    )\\n      external pure\\n      returns(uint256)\\n    {\\n      return _calculateValue(price, amount, decimals);\\n    }\\n\\n\\n      /**\\n     * @notice         - calculates value of tokens and denominates in USD 8\\n     * @dev            - Assumes all oracles return USD responses in 1e8 decimals\\n     * @param price    - oracle price of asset. 8 decimals\\n     * @param amount   - amount of tokens vbeing valued.\\n     * @param decimals - token decimals to remove for usd price\\n     * @return         - total value in usd of all tokens \\n     */\\n    function _calculateValue(\\n      int price,\\n      uint256 amount,\\n      uint8 decimals\\n    )\\n      internal pure\\n      returns(uint256)\\n    {\\n      return price <= 0 ? 0 : (amount * uint(price)) / (1 * 10 ** decimals);\\n    }\\n\\n  \\n\\n  function create(\\n      bytes32 id,\\n      uint256 amount,\\n      address lender,\\n      address token,\\n      address oracle\\n  )\\n      external \\n      returns(ILineOfCredit.Credit memory credit)\\n  {\\n      return _create(id, amount, lender, token, oracle);\\n  }\\n\\n  function _create(\\n      bytes32 id,\\n      uint256 amount,\\n      address lender,\\n      address token,\\n      address oracle\\n  )\\n      internal \\n      returns(ILineOfCredit.Credit memory credit)\\n  {\\n      int price = IOracle(oracle).getLatestAnswer(token);\\n      if(price <= 0 ) { revert NoTokenPrice(); }\\n\\n      (bool passed, bytes memory result) = token.call(\\n          abi.encodeWithSignature(\\\"decimals()\\\")\\n      );\\n      uint8 decimals = !passed ? 18 : abi.decode(result, (uint8));\\n\\n      credit = ILineOfCredit.Credit({\\n          lender: lender,\\n          token: token,\\n          decimals: decimals,\\n          deposit: amount,\\n          principal: 0,\\n          interestAccrued: 0,\\n          interestRepaid: 0\\n      });\\n\\n      emit AddCredit(lender, token, amount, id);\\n\\n      return credit;\\n  }\\n\\n  function repay(\\n    ILineOfCredit.Credit memory credit,\\n    bytes32 id,\\n    uint256 amount\\n  )\\n    external\\n    // TODO don't need to return all uints if we can get events working in library to show up on subgraph\\n    returns (ILineOfCredit.Credit memory)\\n  { unchecked {\\n      if (amount <= credit.interestAccrued) {\\n          credit.interestAccrued -= amount;\\n          credit.interestRepaid += amount;\\n          emit RepayInterest(id, amount);\\n          return credit;\\n      } else {\\n          uint256 interest = credit.interestAccrued;\\n          uint256 principalPayment = amount - interest;\\n\\n          // update individual credit position denominated in token\\n          credit.principal -= principalPayment;\\n          credit.interestRepaid += interest;\\n          credit.interestAccrued = 0;\\n\\n          emit RepayInterest(id, interest);\\n          emit RepayPrincipal(id, principalPayment);\\n\\n          return credit;\\n      }\\n  } }\\n\\n  function withdraw(\\n    ILineOfCredit.Credit memory credit,\\n    bytes32 id,\\n    uint256 amount\\n  )\\n    external\\n    returns (ILineOfCredit.Credit memory)\\n  { unchecked {\\n      if(amount > credit.deposit - credit.principal + credit.interestRepaid) {\\n        revert ILineOfCredit.NoLiquidity(id);\\n      }\\n\\n      if (amount > credit.interestRepaid) {\\n          uint256 interest = credit.interestRepaid;\\n          amount -= interest;\\n\\n          credit.deposit -= amount;\\n          credit.interestRepaid = 0;\\n\\n          // emit events before seeting to 0\\n          emit WithdrawDeposit(id, amount);\\n          emit WithdrawProfit(id, interest);\\n\\n          return credit;\\n      } else {\\n          credit.interestRepaid -= amount;\\n          emit WithdrawProfit(id, amount);\\n          return credit;\\n      }\\n  } }\\n\\n\\n  function accrue(\\n    ILineOfCredit.Credit memory credit,\\n    bytes32 id,\\n    address interest\\n  )\\n    external\\n    returns (ILineOfCredit.Credit memory)\\n  { \\n    return _accrue(credit, id, IInterestRateCredit(interest));\\n  }\\n\\n  function _accrue(\\n    ILineOfCredit.Credit memory credit,\\n    bytes32 id,\\n    IInterestRateCredit interest\\n  )\\n    internal\\n    returns (ILineOfCredit.Credit memory)\\n  { unchecked {\\n      // interest will almost always be less than deposit\\n      // low risk of overflow unless extremely high interest rate\\n\\n      // get token demoninated interest accrued\\n      uint256 accruedToken = interest.accrueInterest(\\n          id,\\n          credit.principal,\\n          credit.deposit\\n      );\\n\\n      // update credits balance\\n      credit.interestAccrued += accruedToken;\\n\\n      emit InterestAccrued(id, accruedToken);\\n      return credit;\\n  } }\\n}\\n\",\"keccak256\":\"0xc4d0601e61130fd6a37a31a915f49eeab62cbc0f5605bc463d57a20f09194a5b\"},\"contracts/utils/CreditListLib.sol\":{\"content\":\"pragma solidity 0.8.9;\\nimport { ILineOfCredit } from \\\"../interfaces/ILineOfCredit.sol\\\";\\nimport { IOracle } from \\\"../interfaces/IOracle.sol\\\";\\nimport { CreditLib } from \\\"./CreditLib.sol\\\";\\n/**\\n  * @title Debt DAO P2P Loan Library\\n  * @author Kiba Gateaux\\n  * @notice Core logic and variables to be reused across all Debt DAO Marketplace loans\\n */\\nlibrary CreditListLib {\\n    /**\\n     * @dev assumes that `id` is stored only once in `positions` array bc no reason for Loans to store multiple times.\\n          This means cleanup on _close() and checks on addDebtPosition are CRITICAL. If `id` is duplicated then the position can't be closed\\n     * @param ids - all current active positions on the loan\\n     * @param id - hash id that must be removed from active positions\\n     * @return newPositions - all active positions on loan after `id` is removed\\n     */\\n    function removePosition(bytes32[] storage ids, bytes32 id) external returns(bool) {\\n      uint256 len = ids.length;\\n\\n      for(uint i = 0; i < len;) {\\n          if(ids[i] == id) {\\n              delete ids[i];\\n              return true;\\n          }\\n          unchecked { ++i; }\\n      }\\n\\n      return true;\\n    }\\n\\n    /**\\n     * @notice - removes debt position from head of repayement queue and puts it at end of line\\n     *         - moves 2nd in line to first\\n     * @param ids - all current active positions on the loan\\n     * @return newPositions - positions after moving first to last in array\\n     */\\n    function stepQ(bytes32[] storage ids) external returns(bool) {\\n      uint256 len = ids.length ;\\n      if(len <= 1) return true; // already ordered\\n\\n      bytes32 last = ids[0];\\n      \\n      if(len == 2) {\\n        ids[0] = ids[1];\\n        ids[1] = last;\\n      } else {\\n        // move all existing ids up in line\\n        for(uint i = 1; i < len; i++) {\\n          ids[i - 1] = ids[i]; // could also clean arr here like in _SoritIntoQ\\n        }\\n        // cycle first el back to end of queue\\n        ids[len - 1] = last;\\n      }\\n      \\n      return true;\\n    }\\n}\\n\",\"keccak256\":\"0xd7569ca8031fd1a9848818fc5fff02b8245d465c1991746ac18619070747855d\"},\"contracts/utils/LoanLib.sol\":{\"content\":\"pragma solidity 0.8.9;\\nimport { ILoan } from \\\"../interfaces/ILoan.sol\\\";\\nimport { IOracle } from \\\"../interfaces/IOracle.sol\\\";\\n/**\\n  * @title Debt DAO P2P Loan Library\\n  * @author Kiba Gateaux\\n  * @notice Core logic and variables to be reused across all Debt DAO Marketplace loans\\n */\\nlibrary LoanLib {\\n    event UpdateLoanStatus(uint256 indexed status); // store as normal uint so it can be indexed in subgraph\\n\\n    enum STATUS {\\n        // \\u00bfhoo dis\\n        // Loan has been deployed but terms and conditions are still being signed off by parties\\n        UNINITIALIZED,\\n        INITIALIZED,\\n\\n        // ITS ALLLIIIIVVEEE\\n        // Loan is operational and actively monitoring status\\n        ACTIVE,\\n        UNDERCOLLATERALIZED,\\n        LIQUIDATABLE, // [#X\\n        DELINQUENT,\\n\\n        // Loan is in distress and paused\\n        LIQUIDATING,\\n        OVERDRAWN,\\n        DEFAULT,\\n        ARBITRATION,\\n\\n        // L\\u00f6n izz ded\\n        // Loan is no longer active, successfully repaid or insolvent\\n        REPAID,\\n        INSOLVENT\\n    }\\n\\n    function updateStatus(STATUS status, STATUS target) external returns(STATUS) {\\n        if (status == target) return status;  // check if it needs updating\\n        status = target;            // set storage in Line contract\\n        emit UpdateLoanStatus(uint256(status));\\n        return status;\\n    }\\n}\\n\",\"keccak256\":\"0xf245bd57fcc50793a607c24d652535b99a7bff5e39e77ef7a8c9d7743d3100ef\"}},\"version\":1}",
  "bytecode": "0x6104c6610053600b82828239805160001a607314610046577f4e487b7100000000000000000000000000000000000000000000000000000000600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100405760003560e01c806302671ea41461004557806324e5546614610082575b600080fd5b81801561005157600080fd5b5061006c60048036038101906100679190610308565b6100bf565b6040516100799190610363565b60405180910390f35b81801561008e57600080fd5b506100a960048036038101906100a4919061037e565b61013d565b6040516100b69190610363565b60405180910390f35b6000808380549050905060005b8181101561013057838582815481106100e8576100e76103ab565b5b906000526020600020015414156101255784818154811061010c5761010b6103ab565b5b9060005260206000200160009055600192505050610137565b8060010190506100cc565b5060019150505b92915050565b6000808280549050905060018111610159576001915050610292565b60008360008154811061016f5761016e6103ab565b5b9060005260206000200154905060028214156101ee5783600181548110610199576101986103ab565b5b9060005260206000200154846000815481106101b8576101b76103ab565b5b906000526020600020018190555080846001815481106101db576101da6103ab565b5b906000526020600020018190555061028b565b6000600190505b8281101561025b578481815481106102105761020f6103ab565b5b9060005260206000200154856001836102299190610413565b8154811061023a576102396103ab565b5b9060005260206000200181905550808061025390610447565b9150506101f5565b50808460018461026b9190610413565b8154811061027c5761027b6103ab565b5b90600052602060002001819055505b6001925050505b919050565b600080fd5b6000819050919050565b6102af8161029c565b81146102ba57600080fd5b50565b6000813590506102cc816102a6565b92915050565b6000819050919050565b6102e5816102d2565b81146102f057600080fd5b50565b600081359050610302816102dc565b92915050565b6000806040838503121561031f5761031e610297565b5b600061032d858286016102bd565b925050602061033e858286016102f3565b9150509250929050565b60008115159050919050565b61035d81610348565b82525050565b60006020820190506103786000830184610354565b92915050565b60006020828403121561039457610393610297565b5b60006103a2848285016102bd565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b6000819050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600061041e826103da565b9150610429836103da565b92508282101561043c5761043b6103e4565b5b828203905092915050565b6000610452826103da565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff821415610485576104846103e4565b5b60018201905091905056fea2646970667358221220a25f7a25b758d671f87d3ddd1693185d1244a676fd8880ea40e869be9766f0fb64736f6c63430008090033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106100405760003560e01c806302671ea41461004557806324e5546614610082575b600080fd5b81801561005157600080fd5b5061006c60048036038101906100679190610308565b6100bf565b6040516100799190610363565b60405180910390f35b81801561008e57600080fd5b506100a960048036038101906100a4919061037e565b61013d565b6040516100b69190610363565b60405180910390f35b6000808380549050905060005b8181101561013057838582815481106100e8576100e76103ab565b5b906000526020600020015414156101255784818154811061010c5761010b6103ab565b5b9060005260206000200160009055600192505050610137565b8060010190506100cc565b5060019150505b92915050565b6000808280549050905060018111610159576001915050610292565b60008360008154811061016f5761016e6103ab565b5b9060005260206000200154905060028214156101ee5783600181548110610199576101986103ab565b5b9060005260206000200154846000815481106101b8576101b76103ab565b5b906000526020600020018190555080846001815481106101db576101da6103ab565b5b906000526020600020018190555061028b565b6000600190505b8281101561025b578481815481106102105761020f6103ab565b5b9060005260206000200154856001836102299190610413565b8154811061023a576102396103ab565b5b9060005260206000200181905550808061025390610447565b9150506101f5565b50808460018461026b9190610413565b8154811061027c5761027b6103ab565b5b90600052602060002001819055505b6001925050505b919050565b600080fd5b6000819050919050565b6102af8161029c565b81146102ba57600080fd5b50565b6000813590506102cc816102a6565b92915050565b6000819050919050565b6102e5816102d2565b81146102f057600080fd5b50565b600081359050610302816102dc565b92915050565b6000806040838503121561031f5761031e610297565b5b600061032d858286016102bd565b925050602061033e858286016102f3565b9150509250929050565b60008115159050919050565b61035d81610348565b82525050565b60006020820190506103786000830184610354565b92915050565b60006020828403121561039457610393610297565b5b60006103a2848285016102bd565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b6000819050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600061041e826103da565b9150610429836103da565b92508282101561043c5761043b6103e4565b5b828203905092915050565b6000610452826103da565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff821415610485576104846103e4565b5b60018201905091905056fea2646970667358221220a25f7a25b758d671f87d3ddd1693185d1244a676fd8880ea40e869be9766f0fb64736f6c63430008090033",
  "devdoc": {
    "author": "Kiba Gateaux",
    "kind": "dev",
    "methods": {
      "removePosition(bytes32[] storage,bytes32)": {
        "details": "assumes that `id` is stored only once in `positions` array bc no reason for Loans to store multiple times. This means cleanup on _close() and checks on addDebtPosition are CRITICAL. If `id` is duplicated then the position can't be closed",
        "params": {
          "id": "- hash id that must be removed from active positions",
          "ids": "- all current active positions on the loan"
        },
        "returns": {
          "_0": "newPositions - all active positions on loan after `id` is removed"
        }
      },
      "stepQ(bytes32[] storage)": {
        "params": {
          "ids": "- all current active positions on the loan"
        },
        "returns": {
          "_0": "newPositions - positions after moving first to last in array"
        }
      }
    },
    "title": "Debt DAO P2P Loan Library",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "stepQ(bytes32[] storage)": {
        "notice": "- removes debt position from head of repayement queue and puts it at end of line         - moves 2nd in line to first"
      }
    },
    "notice": "Core logic and variables to be reused across all Debt DAO Marketplace loans",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}